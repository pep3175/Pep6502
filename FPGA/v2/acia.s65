    .setcpu "6502"
    .include "zeropage.inc65"
    .include "io.inc65"
    .include "macros.inc65"
    ;.include "vdp.inc65"

    .export acia_init
    .export acia_getc
    .export acia_gets
    .export acia_buffer
    .export acia_putc
    .export acia_puts
    .export acia_put_newline

    .bss
    ACIA_BUFFER_LENGTH = 40
acia_buffer:
    .res ACIA_BUFFER_LENGTH + 1, 0

    .code
; Initialize the ACIA
acia_init:
    pha
    lda #(ACIA_PARITY_DISABLE | ACIA_ECHO_DISABLE | ACIA_TX_INT_DISABLE_RTS_LOW | ACIA_RX_INT_DISABLE | ACIA_DTR_LOW)
    sta ACIA_COMMAND
    lda #(ACIA_STOP_BITS_1 | ACIA_DATA_BITS_8 | ACIA_CLOCK_INT | ACIA_BAUD_9600)
    sta ACIA_CONTROL
    pla
    rts

; Send the character in A
acia_putc:
    pha
wait_txd_empty:
    lda ACIA_STATUS
    and #ACIA_STATUS_TX_EMPTY
    beq wait_txd_empty
    pla
    sta ACIA_DATA
    rts

; Send the zero terminated string pointed to by R0
acia_puts:
    phay
    ldy #$ff
next_char:
    iny
    lda (R0),y
    jsr acia_putc
    bne next_char
    play
    rts

; Wait until a character was reveiced and return it in A
acia_getc:
wait_rxd_full:
    lda ACIA_STATUS
    and #ACIA_STATUS_RX_FULL
    beq wait_rxd_full
    lda ACIA_DATA
    rts

; Wait until a \n terminated string was received and store it at (R0)
acia_gets:
    phay
    ld16 R0, acia_buffer
    ldy #0
@read:
    jsr acia_getc
    cmp #$0d
    beq @endString
    sta (R0),y
    jsr acia_putc
    ;jsr vdp_print_char
    iny
    jmp @read
@endString:
    lda #0
    sta (R0),y
    jsr acia_put_newline
    play
    rts

; Send a newline character
acia_put_newline:
    lda #$0a
    jsr acia_putc
    lda #$0d
    jmp acia_putc

vdp_print_char:
    sta VIA1_ORA
    lda #0                  ; clear E bit
    sta VIA1_ORB
    lda #1                  ; send data
    sta VIA1_ORB
    lda #0                  ; clear E bit
    sta VIA1_ORB
    rts
